<html>
<head>
<title>Counting the number of Combinations of a given n-digit number that resolve to an "Ugly Number"</title>
<script>/* This program computes the number of combinations that evaluate to "Ugly Numbers", for a given number. */

nmbr = prompt("Give me a number!");

precomputed = {};

alert("Ugly number count: " + calculate_ugliness(nmbr));



function calculate_mod_x_counts(x, number)
{
	if (!precomputed[number])//already been calculated
	//then calculate it and add it to "precomputed".
	
	{
		//As a preliminary, calculate the number of digits in number.
		var num_digits = Math.floor(Math.log10(number))+1;
		
		//initialize the array which will become our return value to a series of 0s.
		var f = [];
		for (i = 0; i < x; ++i)
		{
			f[i]= 0;
		}
		
		//
		for (i=1; i < num_digits; i++)
		{
			var j= Math.exp(10,i);//j corresponds to the point at which we're splitting our initial string into two substrings.
			var lefthandnum= number/j;
			var left_mod_counts = calculate_mod_x_counts(x, lefthandnum);//the recursive step
			
			var righthandnum= number%j;
			var right_mod_counts = calculate_mod_x_counts(x, righthandnum);
			
			
			//For the given split point, use the mod-x-counts of the substrings to calculate those of the combined string.
			for (k = 0; k < x; ++k)
			{
				for (l = 0; l < x; ++l)
				{
					f[(k+l)%x] += left_mod_counts[k] * right_mod_counts[l];
					f[(k-l)%x] += left_mod_counts[k] * right_mod_counts[l];
				}
			} 
		}
		
		var single_number_mod_count = number % x; //Will be a number from 0-x, exclusive
		f[single_number_mod_count] += 1;
		precomputed[number] = f;
	} //end if !precomputed(number) 
	return precomputed[number];//precalculated or just
}

function calculate_ugliness(number)/*Compute number of combinations that evaluate to a number divisible by 7
OR 5 OR 3 OR 2*/
{
	/*Take advantage of particular trick for calculating if number divisible by 3: If and only if all digits sum to number divisible by 3,
	full number is also divisible by 3. Therefore, either every single combination will be divisible by 3 or none will be.*/
	//WAIT, this doesn't work for subtraction, e.g. 4-2 = 2.
	
	//The following line counts numbers divisible by 2 of the following numbers twice, and numbers divisible by all 3, thrice.
	//debugger
	var result = calculate_mod_x_counts(2, number)[0] + calculate_mod_x_counts(5, number)[0] + calculate_mod_x_counts(7, number)[0]+ calculate_mod_x_counts(3, number)[0];

	result -= (calculate_mod_x_counts((2*5), number)[0] +  calculate_mod_x_counts(2*7, number)[0] + calculate_mod_x_counts(5*7, number)[0]
	+ calculate_mod_x_counts((3*2), number)[0] +  calculate_mod_x_counts(3*5, number)[0] + calculate_mod_x_counts(3*7, number)[0]);
	
	//all the triple cases have now been counted thrice and subtracted thrice, so we need to add them again once
	result += calculate_mod_x_counts((2*5*7), number)[0] + calculate_mod_x_counts((3*5*7), number)[0] + calculate_mod_x_counts((2*3*7), number)[0] + calculate_mod_x_counts((2*3*5), number)[0];
	//Finally, the quadruple case was added 4 times, subtracted six times, added 4 times, so must now be subtracted once.
	result -= calculate_mod_x_counts((2*3*5*7), number)[0];
	return result;	
}





</script>
</head>
</html>